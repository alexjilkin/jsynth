{"version":3,"file":"worklet.js","mappings":"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","sources":["webpack:///../../core/consts.js","webpack:///../../core/modules/createModule.js","webpack:///../../core/modules/delay.js","webpack:///../../core/modules/envelope.js","webpack:///../../core/modules/lowpass/index.js","webpack:///../../core/modules/lowpass/lowpass.js","webpack:///../../core/modules/oscillator.js","webpack:///../../core/synth.js","webpack:///webpack/bootstrap","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///./index.js"],"sourcesContent":["export const sampleRate = 22050\nexport const attackSize = 500;\nexport const releaseSize = 5000;","export default function(func, type = 'transform') {\n    let returnFunc = (u, n, freqModulation) => [u, n, freqModulation]\n\n    if (type === 'generator') {\n        returnFunc = (u, n, freqModulation, args, shouldGenerate) => {\n            return func(u, n, freqModulation, args, shouldGenerate)\n        }\n    } else if (type === 'transform') {\n        returnFunc = (u, n, args) => {\n            return func(u, n, args)\n        }\n    } else if (type === 'monoTransform') {\n        returnFunc = (u, n, args) => {\n            return func(u, n, args)\n        }\n    }\n\n    return {\n        func: returnFunc,\n        type\n    }\n}","import {sampleRate} from '@jsynth/core/consts'\nimport createModule from './createModule'\n\nlet feedbackSize = sampleRate * 4 * 5;\nlet feedback = new Array(feedbackSize).fill(0)\nlet k = 0;\n\nfunction delay(u, n, args) {\n    const {time, depth, gain} = args;\n\n    const delayAmountBySamples = time * sampleRate;\n    const cyclicN = n % feedbackSize\n    feedback[cyclicN] = u;\n    \n    for(let i = 1; i < depth; i++) {     \n        const feedbackIndex = Math.round(Math.abs(cyclicN - (i * delayAmountBySamples)))\n        const feedbackValue = feedback[feedbackIndex]\n\n        u += (Math.pow(gain, i) * feedbackValue)\n    }\n\n    return u;\n}\n\nexport const setTime = v => time = v;\nexport const setDepth = v => depth = v;\n\nexport default createModule(delay, 'transform')","const attackSize = 1000;\nconst releaseSize = 10000;\n\nexport const envelope = (u, n, shouldGenerate, nAtStart, nAtStop) => {\n  const nSinceStart = n - nAtStart\n  if (nSinceStart < attackSize) {\n    return envelopeAttack(u, nSinceStart, attackSize)\n  } \n  \n  if (!shouldGenerate) {\n    const nSinceStop = n - nAtStop\n    if (nSinceStop > releaseSize) {\n      return 0\n    } \n\n    return envelopeRelease(u, nSinceStop, releaseSize)\n  }\n\n  return u\n}\n\nconst envelopeAttack = (y, x, size) => {\n  const m = 1 / (size)\n  return y * (x * m)\n}\n\nconst envelopeRelease = (y, x, size) => {\n  const m = -1 / (size);\n\n  return y * ((x * m) + (1))\n}","import _ from './lowpass'\nexport default _","import createModule from '../createModule'\n\nlet previousResult = 0;\n\nfunction lowpass(u, n, args) {\n    const {frequency} = args\n\n    const result = previousResult + ((frequency) * (u - previousResult))\n    previousResult = result\n\n    return result\n}\n\nexport default createModule(lowpass, 'transform', {})","import {sampleRate} from '@jsynth/core/consts'\nimport createModule from './createModule'\nimport {envelope} from './envelope'\n\nconst amplitude = 1;\nconst PiDividedBySampleRate = Math.PI / sampleRate;\nconst twoPiDividedBySampleRate = PiDividedBySampleRate * 2;\n\n\nconst baseFrequency = 440;\n\nfunction oscillator(u, n, freqModulation, args) {\n    const {sineAmount, sawAmount, squareAmount, nAtStart, nAtStop, shouldGenerate} = args\n    \n    const totalAmount = Math.abs(sineAmount) + Math.abs(sawAmount) + Math.abs(squareAmount)\n    const wave =  ((getSineWave(n, freqModulation) * Math.abs(sineAmount)) + (getSquareWave(n, freqModulation) * Math.abs(squareAmount)) + (getSawWave(n, freqModulation) * Math.abs(sawAmount))) / totalAmount\n\n    return envelope(wave, n, shouldGenerate, nAtStart, nAtStop);\n}\n\nexport function getSineWave(n, freqModulation) {\n    const frequency = baseFrequency * freqModulation\n    const cyclicN= n % (~~(sampleRate / frequency));\n\n    return Math.cos(frequency * twoPiDividedBySampleRate * cyclicN) * amplitude\n}\n\nexport function getSquareWave(n, freqModulation) {\n  const frequency = baseFrequency * freqModulation\n  const cyclicX = n % (~~(sampleRate / frequency));\n\n  return Math.sign(Math.sin(twoPiDividedBySampleRate* (frequency) * (cyclicX % sampleRate))) * (amplitude / 2);\n}\n\nexport function getSawWave(n, freqModulation) {\n  const frequency = baseFrequency * freqModulation\n  const cyclicX = n % (~~(sampleRate / frequency));\n\n  return (-1) * (amplitude / 2)  * arcctg(ctg((cyclicX) * frequency * PiDividedBySampleRate)) / Math.PI\n}\n\nfunction ctg(x) { return 1 / Math.tan(x); }\nfunction arcctg(x) { return Math.PI / 2 - Math.atan(x); }\nexport default createModule(oscillator, 'generator')","let masterClock = 0;\n\nexport const getMasterClock = () => masterClock\n\nlet modules = []\nlet generatingModules = []\nlet monoTransformModules = []\n\nexport const subscribeModule = (type, module) => {\n  switch (type) {\n    case 'generator': \n      subscribeGeneratingModule(module)\n      break\n    case 'monoTransform':\n      subscribeMonoTransformModule(module)\n      break\n    case 'transform':\n      subscribeTransformingModule(module)\n      break\n  }\n}\n  \nconst subscribeTransformingModule = (module) => {\n  modules.push(module)\n\n  return () => {\n    const index = modules.findIndex(_module => _module === module);\n    modules = [...modules.slice(0, index), ...modules.slice(index + 1)]\n  }\n}\n\nconst subscribeMonoTransformModule = (module) => {\n  monoTransformModules.push(module)\n  return () => {\n    const index = monoTransformModules.findIndex(_module => _module === module);\n    monoTransformModules = [...monoTransformModules.slice(0, index), ...monoTransformModules.slice(index + 1)]\n  }\n}\n\nconst subscribeGeneratingModule = (module) => {\n  generatingModules.push(module)\n\n  return () => {\n    const index = generatingModules.findIndex(_module => _module === module);\n    generatingModules = [...generatingModules.slice(0, index), ...generatingModules.slice(index + 1)]\n  }\n}\nexport const clearModules = () => {\n  modules = []\n  generatingModules = []\n  monoTransformModules = []\n}\n\nexport function waveGenerator(triggers) {\n  let wave = 0;\n\n  Object.keys(triggers).forEach((id) => {\n    const {frequencyModulation, shouldGenerate} = triggers[id]\n    \n    handleTimings(shouldGenerate, id)\n    wave = generatingModules.reduce((acc, {func, args}) => {\n      return acc + func(acc, masterClock, frequencyModulation, {...args, nAtStart: timings[id].nAtStart, nAtStop: timings[id].nAtStop, shouldGenerate})\n    }, wave)\n  })\n\n  wave = modules.reduce((acc, {func, args}) => {\n    return func(acc, masterClock, args)\n  }, wave)\n  masterClock++\n  \n  // Decrease volume \n  const mixVolume =  0.3\n  return wave * mixVolume\n}\n\nconst timings = {}\n\nfunction handleTimings(shouldGenerate, id) {\n  let timing = timings[id] || {}\n  const {isPressed} = timing\n\n  if (shouldGenerate && !isPressed) {\n    timing = {\n      ...timing,\n      nAtStart: masterClock,\n      isPressed: true\n    }\n  } else if (!shouldGenerate && isPressed) {\n    timing = {\n      ...timing,\n      nAtStop: masterClock,\n      isPressed: false\n    }\n  }\n\n  timings[id] = timing\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import {waveGenerator, subscribeModule, clearModules} from '@jsynth/core/synth';\nimport delay from '@jsynth/core/modules/delay'\nimport lowpass from '@jsynth/core/modules/lowpass'\nimport oscillator from '@jsynth/core/modules/oscillator'\n\nconst availableModules = {delay, lowpass, oscillator}\nlet triggers = {}\n\nclass SynthWorklet extends AudioWorkletProcessor {\n    constructor(...args) {\n      super(...args);\n\n      this.port.onmessage = e => {\n        const data = JSON.parse(e.data)\n        triggers = data.triggers\n        \n        if (data.isUpdated) {\n          clearModules()\n          data.modules.forEach(({name, args, type}) => {\n            subscribeModule(type, {...availableModules[name], args})\n          })\n        }\n      }\n    }\n  \n    process(inputs, outputs, parameters) {\n      const input = inputs[0];\n      const output = outputs[0];\n\n      for (let channel = 0; channel < output.length; ++channel) {\n          for (let i = 0; i < output[channel].length; ++i) {\n            try {\n              output[channel][i] = waveGenerator(triggers)\n            } catch (err) {\n              console.log(err)\n            }\n            \n          }\n      }\n  \n      return true;\n    }\n  }\n  \n  registerProcessor('synth', SynthWorklet);"],"names":["waveGenerator","subscribeModule","clearModules","delay","lowpass","oscillator","availableModules","triggers","SynthWorklet","args","port","onmessage","e","data","JSON","parse","isUpdated","modules","forEach","name","type","inputs","outputs","parameters","input","output","channel","length","i","err","console","log","AudioWorkletProcessor","registerProcessor"],"sourceRoot":""}