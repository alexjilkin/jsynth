{"version":3,"file":"worklet.js","mappings":";;;;;;;;;;;;;;;;AAAO;AACA;AACA;;;;;;;;;;;;;;;ACFP,6BAAe,oCAAU;AACzB;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACrBiD;AACP;;AAE1C,mBAAmB,2DAAU;AAC7B;AACA;;AAEA;AACA,UAAU,oBAAoB;;AAE9B,sCAAsC,2DAAU;AAChD;AACA;;AAEA,kBAAkB,WAAW;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEO;AACA;;AAEP,iEAAe,yDAAY,oBAAoB,EAAC;;;;;;;;;;;;;;;;;AC3BN;;AAE1C;;AAEA;AACA,UAAU,OAAO;;AAEjB;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,iEAAe,yDAAY,4BAA4B,CAAC,EAAC;;;;;;;;;;;;;;;AClCzD;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;AC9B0B;AAC1B,iEAAe,gDAAC,EAAC;;;;;;;;;;;;;;;;ACD0B;;AAE3C;;AAEA;AACA,UAAU,YAAY;;AAEtB;AACA;;AAEA;AACA;;AAEA,iEAAe,yDAAY,yBAAyB,CAAC,EAAC;;;;;;;;;;;;;;;;;;;;;ACbL;AACP;AACJ;;AAEtC;AACA,wCAAwC,2DAAU;AAClD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU,mFAAmF;;AAE7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS,mDAAQ;AACjB;;AAEO;AACP;AACA,yBAAyB,2DAAU;;AAEnC;;AAEA;AACA;;AAEO;AACP;AACA,yBAAyB,2DAAU;;AAEnC,8DAA8D,2DAAU;AACxE;AACA;;AAEO;AACP;AACA,yBAAyB,2DAAU;;AAEnC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,yDAAY,yBAAyB,EAAC;;;;;;;;;;;;;;;;;;ACtErD;;AAEO;;AAEP;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEA;AACA,YAAY,sCAAsC;;AAElD;AACA;AACA,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA,6BAA6B,YAAY;AACzC;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,UAAU,YAAY;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;UCnHA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AAEA,IAAMO,gBAAgB,GAAG;AAAEJ,EAAAA,KAAK,EAALA,kEAAF;AAASC,EAAAA,OAAO,EAAPA,oEAAT;AAAkBC,EAAAA,UAAU,EAAVA,uEAAlB;AAA8BC,EAAAA,UAAU,EAAVA,uEAAUA;AAAxC,CAAzB;AACA,IAAIE,QAAQ,GAAG,EAAf;;IAEMC;;;;;AAGJ,0BAAqB;AAAA;;AAAA;;AAAA,sCAANC,IAAM;AAANA,MAAAA,IAAM;AAAA;;AACnB,oDAASA,IAAT;;AADmB,4DAFb,CAEa;;AAGnB,UAAKC,IAAL,CAAUC,SAAV,GAAsB,UAACC,CAAD,EAAO;AAC3B,UAAMC,IAAI,GAAGC,IAAI,CAACC,KAAL,CAAWH,CAAC,CAACC,IAAb,CAAb;AACAN,MAAAA,QAAQ,GAAGM,IAAI,CAACN,QAAhB;;AAEA,UAAIM,IAAI,CAACG,SAAT,EAAoB;AAClBf,QAAAA,gEAAY;AACZY,QAAAA,IAAI,CAACI,OAAL,CAAaC,OAAb,CAAqB,gBAA0B;AAAA,cAAvBC,IAAuB,QAAvBA,IAAuB;AAAA,cAAjBV,IAAiB,QAAjBA,IAAiB;AAAA,cAAXW,IAAW,QAAXA,IAAW;AAC7CpB,UAAAA,mEAAe,CAACoB,IAAD,kCAAYd,gBAAgB,CAACa,IAAD,CAA5B;AAAoCV,YAAAA,IAAI,EAAJA;AAApC,aAAf;AACD,SAFD;AAGD;AACF,KAVD;;AAHmB;AAcpB;;;;WAED,iBAAQY,MAAR,EAAgBC,OAAhB,EAAyBC,UAAzB,EAAqC;AACnC,UAAMC,KAAK,GAAGH,MAAM,CAAC,CAAD,CAApB;AACA,UAAMI,MAAM,GAAGH,OAAO,CAAC,CAAD,CAAtB;;AAEA,WAAK,IAAII,OAAO,GAAG,CAAnB,EAAsBA,OAAO,GAAGD,MAAM,CAACE,MAAvC,EAA+C,EAAED,OAAjD,EAA0D;AACxD,aAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,MAAM,CAACC,OAAD,CAAN,CAAgBC,MAApC,EAA4C,EAAEC,CAA9C,EAAiD;AAC/C,cAAI;AACFH,YAAAA,MAAM,CAACC,OAAD,CAAN,CAAgBE,CAAhB,IAAqB7B,iEAAa,CAACQ,QAAD,CAAlC;AACD,WAFD,CAEE,OAAOsB,GAAP,EAAY;AACZC,YAAAA,OAAO,CAACC,GAAR,CAAYF,GAAZ;AACD;AACF;AACF;;AAED,WAAKnB,IAAL,CAAUsB,WAAV,CAAsBP,MAAM,CAAC,CAAD,CAA5B;AAEA,WAAKQ,KAAL;AAEA,aAAO,IAAP;AACD;;;;iCAtCwBC;;AAyC3BC,iBAAiB,CAAC,OAAD,EAAU3B,YAAV,CAAjB,C","sources":["webpack:///../../core/consts.js","webpack:///../../core/modules/createModule.js","webpack:///../../core/modules/delay.js","webpack:///../../core/modules/distortion.js","webpack:///../../core/modules/envelope.js","webpack:///../../core/modules/lowpass/index.js","webpack:///../../core/modules/lowpass/lowpass.js","webpack:///../../core/modules/oscillator.js","webpack:///../../core/synth.js","webpack:///webpack/bootstrap","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///./index.js"],"sourcesContent":["export const sampleRate = 22050;\nexport const attackSize = 500;\nexport const releaseSize = 5000;\n","export default function (func, type = \"transform\") {\n  let returnFunc = (u, n, freqModulation) => [u, n, freqModulation];\n\n  if (type === \"generator\") {\n    returnFunc = (u, n, freqModulation, args, shouldGenerate) => {\n      return func(u, n, freqModulation, args, shouldGenerate);\n    };\n  } else if (type === \"transform\") {\n    returnFunc = (u, n, args) => {\n      return func(u, n, args);\n    };\n  } else if (type === \"monoTransform\") {\n    returnFunc = (u, n, args) => {\n      return func(u, n, args);\n    };\n  }\n\n  return {\n    func: returnFunc,\n    type,\n  };\n}\n","import { sampleRate } from \"@jsynth/core/consts\";\nimport createModule from \"./createModule\";\n\nlet feedbackSize = sampleRate * 4 * 5;\nlet feedback = new Array(feedbackSize).fill(0);\nlet k = 0;\n\nfunction delay(u, n, args) {\n  const { time, depth, gain } = args;\n\n  const delayAmountBySamples = time * sampleRate;\n  const cyclicN = n % feedbackSize;\n  feedback[cyclicN] = u;\n\n  for (let i = 1; i < depth; i++) {\n    const feedbackIndex = Math.round(Math.abs(cyclicN - i * delayAmountBySamples));\n    const feedbackValue = feedback[feedbackIndex];\n\n    u += Math.pow(gain, i) * feedbackValue;\n  }\n\n  return u;\n}\n\nexport const setTime = (v) => (time = v);\nexport const setDepth = (v) => (depth = v);\n\nexport default createModule(delay, \"transform\");\n","import createModule from \"./createModule\";\n\nlet prevValue = 0;\n\nconst distortion = (u, n, args) => {\n  const { gain } = args;\n\n  if (gain < 0.2) {\n    return u;\n  }\n  return forwardEulerDistortion(u * 2, n, 1 / gain);\n};\n\nexport const forwardEulerDistortion = (y, x, gain) => {\n  // \"Normalize\" to 9\n  let value = y * 9;\n\n  // Cut\n  if (value > 4.5) {\n    value = 4.5;\n  } else if (y < -4.5) {\n    value = -4.5;\n  }\n\n  value = prevValue + circuit(prevValue, value, gain) * 1;\n  prevValue = value;\n\n  return value / 9;\n};\n\nfunction circuit(x, u, R) {\n  return (u - x) / (R * 10) - 0.504 * Math.sinh(x / 45.3);\n}\n\nexport default createModule(distortion, \"transform\", {});\n","const attackSize = 1000;\nconst releaseSize = 10000;\n\nexport const envelope = (u, n, shouldGenerate, nAtStart, nAtStop) => {\n  const nSinceStart = n - nAtStart;\n  if (nSinceStart < attackSize) {\n    return envelopeAttack(u, nSinceStart, attackSize);\n  }\n\n  if (!shouldGenerate) {\n    const nSinceStop = n - nAtStop;\n    if (nSinceStop > releaseSize) {\n      return 0;\n    }\n\n    return envelopeRelease(u, nSinceStop, releaseSize);\n  }\n\n  return u;\n};\n\nconst envelopeAttack = (y, x, size) => {\n  const m = 1 / size;\n  return y * (x * m);\n};\n\nconst envelopeRelease = (y, x, size) => {\n  const m = -1 / size;\n\n  return y * (x * m + 1);\n};\n","import _ from \"./lowpass\";\nexport default _;\n","import createModule from \"../createModule\";\n\nlet previousResult = 0;\n\nfunction lowpass(u, n, args) {\n  const { frequency } = args;\n\n  const result = previousResult + frequency * (u - previousResult);\n  previousResult = result;\n\n  return result;\n}\n\nexport default createModule(lowpass, \"transform\", {});\n","import { sampleRate } from \"@jsynth/core/consts\";\nimport createModule from \"./createModule\";\nimport { envelope } from \"./envelope\";\n\nconst amplitude = 1;\nconst PiDividedBySampleRate = Math.PI / sampleRate;\nconst twoPiDividedBySampleRate = PiDividedBySampleRate * 2;\n\nconst baseFrequency = 440;\n\nconst algoTypeToFunc = {\n  1: (x) => 0,\n  2: (x) => 0,\n  3: (x) => Math.sin(x * 20),\n  4: (x) => Math.tan(x * 10),\n  5: (x) => Math.sin(x * 2),\n  6: (x) => (Math.sin(x) + Math.cos(x)),\n}\n\nconst getModulator = (algoType, x) => {\n  return algoTypeToFunc[algoType] ? algoTypeToFunc[algoType](x) : 0\n}\n\nfunction oscillator(u, n, freqModulation, args) {\n  const { sineAmount, sawAmount, squareAmount, algoType, nAtStart, nAtStop, shouldGenerate } = args;\n\n  const totalAmount = Math.abs(sineAmount) + Math.abs(sawAmount) + Math.abs(squareAmount);\n  const wave =\n    (\n      getSineWave(n, freqModulation, algoType) * Math.abs(sineAmount) +\n      getSquareWave(n, freqModulation, algoType) * Math.abs(squareAmount) +\n      getSawWave(n, freqModulation, algoType) * Math.abs(sawAmount)\n    ) /\n    totalAmount;\n\n  return envelope(wave, n, shouldGenerate, nAtStart, nAtStop);\n}\n\nexport function getSineWave(n, freqModulation, algoType) {\n  const frequency = baseFrequency * freqModulation;\n  const cyclicN = n % ~~(sampleRate / frequency);\n\n  const x = frequency * twoPiDividedBySampleRate * cyclicN;\n\n  return Math.cos(x + getModulator(algoType, x)) * amplitude;\n}\n\nexport function getSquareWave(n, freqModulation, algoType) {\n  const frequency = baseFrequency * freqModulation;\n  const cyclicN = n % ~~(sampleRate / frequency);\n\n  const x = twoPiDividedBySampleRate * frequency * (cyclicN % sampleRate)\n  return Math.sign(Math.sin(x + getModulator(algoType, x))) * amplitude;\n}\n\nexport function getSawWave(n, freqModulation, algoType) {\n  const frequency = baseFrequency * freqModulation;\n  const cyclicN = n % ~~(sampleRate / frequency);\n\n  const x = cyclicN * frequency * PiDividedBySampleRate;\n\n  return (-amplitude * arcctg(ctg(x) + getModulator(algoType, x))) / Math.PI;\n}\n\nfunction ctg(x) {\n  return 1 / Math.tan(x);\n}\nfunction arcctg(x) {\n  return Math.PI / 2 - Math.atan(x);\n}\nexport default createModule(oscillator, \"generator\");\n","let masterClock = 0;\n\nexport const getMasterClock = () => masterClock;\n\nlet modules = [];\nlet generatingModules = [];\nlet monoTransformModules = [];\n\nexport const subscribeModule = (type, module) => {\n  switch (type) {\n    case \"generator\":\n      subscribeGeneratingModule(module);\n      break;\n    case \"monoTransform\":\n      subscribeMonoTransformModule(module);\n      break;\n    case \"transform\":\n      subscribeTransformingModule(module);\n      break;\n  }\n};\n\nconst subscribeTransformingModule = (module) => {\n  modules.push(module);\n\n  return () => {\n    const index = modules.findIndex((_module) => _module === module);\n    modules = [...modules.slice(0, index), ...modules.slice(index + 1)];\n  };\n};\n\nconst subscribeMonoTransformModule = (module) => {\n  monoTransformModules.push(module);\n  return () => {\n    const index = monoTransformModules.findIndex((_module) => _module === module);\n    monoTransformModules = [\n      ...monoTransformModules.slice(0, index),\n      ...monoTransformModules.slice(index + 1),\n    ];\n  };\n};\n\nconst subscribeGeneratingModule = (module) => {\n  generatingModules.push(module);\n\n  return () => {\n    const index = generatingModules.findIndex((_module) => _module === module);\n    generatingModules = [...generatingModules.slice(0, index), ...generatingModules.slice(index + 1)];\n  };\n};\nexport const clearModules = () => {\n  modules = [];\n  generatingModules = [];\n  monoTransformModules = [];\n};\n\nexport function waveGenerator(triggers) {\n  let u = 0;\n  let contributingTriggersCount = 1;\n\n  Object.keys(triggers).forEach((id) => {\n    const { frequencyModulation, shouldGenerate } = triggers[id];\n\n    handleTimings(shouldGenerate, id);\n    u = generatingModules.reduce(\n      (acc, { func, args }) =>\n        acc +\n        func(acc, masterClock, frequencyModulation, {\n          ...args,\n          nAtStart: timings[id].nAtStart,\n          nAtStop: timings[id].nAtStop,\n          shouldGenerate,\n        }),\n      u\n    );\n\n    if (Math.abs(u) > 0.01) {\n      contributingTriggersCount++;\n    }\n  });\n\n  // Reduce volume due to polysynthing\n  u = u / Math.sqrt(contributingTriggersCount);\n\n  u = modules.reduce((acc, { func, args }) => {\n    return func(acc, masterClock, args);\n  }, u);\n  masterClock++;\n\n  // Decrease volume\n  const mixVolume = 0.4;\n  return u * mixVolume;\n}\n\nconst timings = {};\n\nfunction handleTimings(shouldGenerate, id) {\n  let timing = timings[id] || {};\n  const { isPressed } = timing;\n\n  if (shouldGenerate && !isPressed) {\n    timing = {\n      ...timing,\n      nAtStart: masterClock,\n      isPressed: true,\n    };\n  } else if (!shouldGenerate && isPressed) {\n    timing = {\n      ...timing,\n      nAtStop: masterClock,\n      isPressed: false,\n    };\n  }\n\n  timings[id] = timing;\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { waveGenerator, subscribeModule, clearModules } from \"@jsynth/core/synth\";\nimport delay from \"@jsynth/core/modules/delay\";\nimport lowpass from \"@jsynth/core/modules/lowpass\";\nimport oscillator from \"@jsynth/core/modules/oscillator\";\nimport distortion from \"@jsynth/core/modules/distortion\";\n\nconst availableModules = { delay, lowpass, oscillator, distortion };\nlet triggers = {};\n\nclass SynthWorklet extends AudioWorkletProcessor {\n  count = 1;\n\n  constructor(...args) {\n    super(...args);\n\n    this.port.onmessage = (e) => {\n      const data = JSON.parse(e.data);\n      triggers = data.triggers;\n\n      if (data.isUpdated) {\n        clearModules();\n        data.modules.forEach(({ name, args, type }) => {\n          subscribeModule(type, { ...availableModules[name], args });\n        });\n      }\n    };\n  }\n\n  process(inputs, outputs, parameters) {\n    const input = inputs[0];\n    const output = outputs[0];\n\n    for (let channel = 0; channel < output.length; ++channel) {\n      for (let i = 0; i < output[channel].length; ++i) {\n        try {\n          output[channel][i] = waveGenerator(triggers);\n        } catch (err) {\n          console.log(err);\n        }\n      }\n    }\n\n    this.port.postMessage(output[0]);\n\n    this.count++;\n\n    return true;\n  }\n}\n\nregisterProcessor(\"synth\", SynthWorklet);\n"],"names":["waveGenerator","subscribeModule","clearModules","delay","lowpass","oscillator","distortion","availableModules","triggers","SynthWorklet","args","port","onmessage","e","data","JSON","parse","isUpdated","modules","forEach","name","type","inputs","outputs","parameters","input","output","channel","length","i","err","console","log","postMessage","count","AudioWorkletProcessor","registerProcessor"],"sourceRoot":""}